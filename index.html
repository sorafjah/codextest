<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Minimal 3D Pinball</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #0d0f1a;
      color: #f0f0f0;
      font-family: 'Segoe UI', sans-serif;
    }
    #ui {
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(0, 0, 0, 0.4);
      padding: 8px 12px;
      border-radius: 8px;
      backdrop-filter: blur(6px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.35);
    }
    #ui button {
      margin-top: 6px;
      width: 100%;
      padding: 6px 8px;
      border: none;
      border-radius: 6px;
      background: #3a7bd5;
      color: white;
      font-weight: bold;
      cursor: pointer;
    }
    #overlay {
      position: fixed;
      inset: 0;
      z-index: 2;
      touch-action: none;
    }
    #stage {
      width: 100vw;
      height: 100vh;
      display: block;
    }
  </style>
</head>
<body>
  <div id="ui">
    <div>Score: <span id="score">0</span></div>
    <div>Miss: <span id="miss">0</span></div>
    <button id="reset">リセット</button>
    <div style="font-size:12px; margin-top:4px; line-height:1.4;">
      PC: A/←=左, L/→=右, Space=打ち出し<br />
      Mobile: 左右タップ, 下部スワイプで打ち出し
    </div>
  </div>
  <canvas id="stage"></canvas>
  <div id="overlay"></div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/controls/OrbitControls.js';
    import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

    const config = {
      table: { width: 10, length: 18, tilt: 0.18 },
      ball: { radius: 0.35, mass: 0.2, restitution: 0.4, friction: 0.02 },
      flipper: { length: 2.2, thickness: 0.35, angle: 22 * Math.PI/180, motor: 12 },
      bumper: { radius: 0.8, restitution: 1.3, impulse: 6 },
      spawn: { x: 3.2, y: 1.2, z: 7 },
      outZone: { z: -7.6, width: 3.2 },
      launchImpulse: 5,
    };

    const canvas = document.getElementById('stage');
    const overlay = document.getElementById('overlay');
    const scoreEl = document.getElementById('score');
    const missEl = document.getElementById('miss');
    const resetBtn = document.getElementById('reset');

    let scene, camera, renderer, controls;
    let world;
    let ballBody, ballMesh;
    let flippers = {};
    let bumpers = [];
    let score = 0;
    let miss = 0;
    let lastHitTime = 0;

    init();
    animate();

    function init() {
      // Scene & camera
      scene = new THREE.Scene();
      scene.background = new THREE.Color('#0d0f1a');
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 16, 18);
      camera.lookAt(0, 0, 0);

      renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;

      controls = new OrbitControls(camera, renderer.domElement);
      controls.enablePan = false;
      controls.enableZoom = false;
      controls.enabled = false;

      const ambient = new THREE.AmbientLight(0xffffff, 0.4);
      scene.add(ambient);
      const dir = new THREE.DirectionalLight(0xffffff, 0.8);
      dir.position.set(6, 12, 10);
      dir.castShadow = true;
      scene.add(dir);

      // Physics world
      world = new CANNON.World({ gravity: new CANNON.Vec3(0, -9.82, 0) });
      world.broadphase = new CANNON.SAPBroadphase(world);
      world.defaultContactMaterial.friction = 0.1;
      world.defaultContactMaterial.restitution = 0.3;

      // Tilted floor
      const floorGeo = new THREE.PlaneGeometry(config.table.width, config.table.length);
      const floorMat = new THREE.MeshPhongMaterial({ color: '#12334f', side: THREE.DoubleSide });
      const floorMesh = new THREE.Mesh(floorGeo, floorMat);
      floorMesh.receiveShadow = true;
      floorMesh.rotation.x = -Math.PI / 2;
      floorMesh.position.y = 0;
      floorMesh.rotateX(config.table.tilt);
      scene.add(floorMesh);

      const floorBody = new CANNON.Body({ mass: 0, shape: new CANNON.Plane(), material: new CANNON.Material({ friction: 0.2, restitution: 0.2 }) });
      floorBody.quaternion.setFromEuler(-config.table.tilt, 0, 0, 'XYZ');
      world.addBody(floorBody);

      // Walls
      createWalls();

      // Bumpers
      createBumpers();

      // Flippers
      createFlippers();

      // Ball
      createBall();

      // UI
      resetBtn.addEventListener('click', resetGame);
      window.addEventListener('resize', onResize);
      setupControls();
    }

    function createWalls() {
      const { width, length, tilt } = config.table;
      const wallHeight = 1.6;
      const wallThickness = 0.3;
      const mat = new THREE.MeshPhongMaterial({ color: '#1f6feb' });

      const positions = [
        { x: -width/2 - wallThickness/2, y: wallHeight/2, z: 0, sx: wallThickness, sy: wallHeight, sz: length },
        { x: width/2 + wallThickness/2, y: wallHeight/2, z: 0, sx: wallThickness, sy: wallHeight, sz: length },
        { x: 0, y: wallHeight/2, z: length/2 + wallThickness/2, sx: width + wallThickness*2, sy: wallHeight, sz: wallThickness },
        { x: -(width/2 - config.outZone.width/2 - 0.4), y: wallHeight/2, z: -length/2 - wallThickness/2 + 2, sx: (width - config.outZone.width)/2, sy: wallHeight, sz: wallThickness },
        { x: (width/2 - config.outZone.width/2 - 0.4), y: wallHeight/2, z: -length/2 - wallThickness/2 + 2, sx: (width - config.outZone.width)/2, sy: wallHeight, sz: wallThickness },
      ];

      positions.forEach(p => {
        const mesh = new THREE.Mesh(new THREE.BoxGeometry(p.sx, p.sy, p.sz), mat);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        mesh.position.set(p.x, p.y, p.z);
        mesh.rotateX(config.table.tilt);
        scene.add(mesh);

        const shape = new CANNON.Box(new CANNON.Vec3(p.sx/2, p.sy/2, p.sz/2));
        const body = new CANNON.Body({ mass: 0, shape, position: new CANNON.Vec3(p.x, p.y, p.z) });
        body.quaternion.setFromEuler(-tilt, 0, 0, 'XYZ');
        world.addBody(body);
      });

      // Out sensor
      const sensor = new CANNON.Body({ mass: 0, type: CANNON.Body.KINEMATIC });
      sensor.addShape(new CANNON.Box(new CANNON.Vec3(config.outZone.width/2, 1, 1.4)));
      sensor.position.set(0, -0.5, -length/2 - 0.2);
      sensor.collisionResponse = false;
      sensor.addEventListener('collide', (e) => {
        if (e.body === ballBody) handleOut();
      });
      world.addBody(sensor);
    }

    function createBumpers() {
      const bumperPositions = [
        { x: -2.5, z: 0 },
        { x: 2.5, z: 0 },
        { x: 0, z: 4 },
      ];
      const mat = new THREE.MeshPhongMaterial({ color: '#ffb703' });
      const bumperMaterial = new CANNON.Material({ restitution: config.bumper.restitution });

      bumperPositions.forEach((p, i) => {
        const geo = new THREE.SphereGeometry(config.bumper.radius, 24, 16);
        const mesh = new THREE.Mesh(geo, mat);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        mesh.position.set(p.x, config.bumper.radius, p.z);
        mesh.rotateX(config.table.tilt);
        scene.add(mesh);

        const body = new CANNON.Body({ mass: 0, material: bumperMaterial });
        body.addShape(new CANNON.Sphere(config.bumper.radius));
        body.position.set(p.x, config.bumper.radius, p.z);
        body.quaternion.setFromEuler(-config.table.tilt, 0, 0, 'XYZ');
        bumpers.push(body);
        world.addBody(body);
      });
    }

    function createFlippers() {
      const { length, thickness, angle, motor } = config.flipper;
      const baseY = 0.4;
      const zPos = -config.table.length/2 + 2.2;
      const offsetX = 2.3;
      const matL = new THREE.MeshPhongMaterial({ color: '#d62828' });
      const matR = new THREE.MeshPhongMaterial({ color: '#4cc9f0' });

      const makeFlipper = (side) => {
        const sign = side === 'left' ? -1 : 1;
        const geo = new THREE.BoxGeometry(length, thickness, 0.7);
        const mesh = new THREE.Mesh(geo, side === 'left' ? matL : matR);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        mesh.position.set(sign * offsetX, baseY, zPos);
        scene.add(mesh);

        const shape = new CANNON.Box(new CANNON.Vec3(length/2, thickness/2, 0.35));
        const body = new CANNON.Body({ mass: 1 });
        body.addShape(shape);
        body.position.set(sign * offsetX, baseY, zPos);
        body.quaternion.setFromEuler(-config.table.tilt, 0, 0, 'XYZ');
        body.angularDamping = 0.5;
        const pivot = new CANNON.Vec3(sign * (offsetX - length/2 + 0.2), baseY, zPos);
        const hinge = new CANNON.HingeConstraint(body, { pivotA: new CANNON.Vec3(sign * -length/2 + 0.2, 0, 0), axisA: new CANNON.Vec3(0,1,0), pivotB: pivot, axisB: new CANNON.Vec3(0,1,0) });
        hinge.collideConnected = false;
        hinge.setLimits(sign * -angle, sign * angle, 0.5, 0.5);
        hinge.enableMotor();
        hinge.setMotorSpeed(0);
        hinge.motorTargetVelocity = 0;
        world.addConstraint(hinge);
        world.addBody(body);

        mesh.quaternion.copy(body.quaternion);
        flippers[side] = { mesh, body, hinge, sign };
      };

      makeFlipper('left');
      makeFlipper('right');
    }

    function createBall() {
      const geo = new THREE.SphereGeometry(config.ball.radius, 32, 24);
      const mat = new THREE.MeshStandardMaterial({ color: '#e5e5e5', metalness: 0.6, roughness: 0.2 });
      ballMesh = new THREE.Mesh(geo, mat);
      ballMesh.castShadow = true;
      ballMesh.receiveShadow = true;
      scene.add(ballMesh);

      const shape = new CANNON.Sphere(config.ball.radius);
      ballBody = new CANNON.Body({ mass: config.ball.mass, shape });
      ballBody.linearDamping = 0.02;
      ballBody.angularDamping = 0.02;
      ballBody.material = new CANNON.Material({ friction: config.ball.friction, restitution: config.ball.restitution });
      ballBody.addEventListener('collide', onBallCollide);
      world.addBody(ballBody);
      respawnBall();
    }

    function respawnBall() {
      ballBody.position.set(config.spawn.x, config.spawn.y, config.spawn.z);
      ballBody.velocity.set(0,0,0);
      ballBody.angularVelocity.set(0,0,0);
    }

    function handleOut() {
      miss++;
      missEl.textContent = miss;
      setTimeout(respawnBall, 800);
    }

    function onBallCollide(event) {
      const target = event.body;
      if (!target) return;
      const bumperIndex = bumpers.indexOf(target);
      if (bumperIndex >= 0) {
        const now = performance.now();
        if (now - lastHitTime > 120) {
          score += 100;
          scoreEl.textContent = score;
          const normal = event.contact?.ni || new CANNON.Vec3(0,1,0);
          const impulse = new CANNON.Vec3().copy(normal).scale(-config.bumper.impulse);
          ballBody.applyImpulse(impulse, event.contact?.ri || new CANNON.Vec3());
          lastHitTime = now;
        }
      }
    }

    function setFlipper(side, active) {
      const f = flippers[side];
      if (!f) return;
      const speed = config.flipper.motor * (active ? (side === 'left' ? 1 : -1) : (side === 'left' ? -1 : 1));
      f.hinge.setMotorSpeed(speed);
    }

    function launchBall() {
      ballBody.applyImpulse(new CANNON.Vec3(0, 0, -config.launchImpulse), new CANNON.Vec3(0,0,0));
    }

    function setupControls() {
      const keyDown = (e) => {
        if (['a','ArrowLeft'].includes(e.key)) setFlipper('left', true);
        if (['l','ArrowRight'].includes(e.key)) setFlipper('right', true);
        if (e.code === 'Space') launchBall();
      };
      const keyUp = (e) => {
        if (['a','ArrowLeft'].includes(e.key)) setFlipper('left', false);
        if (['l','ArrowRight'].includes(e.key)) setFlipper('right', false);
      };
      window.addEventListener('keydown', keyDown);
      window.addEventListener('keyup', keyUp);

      let touchStart = null;
      overlay.addEventListener('pointerdown', (e) => {
        const rect = overlay.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        touchStart = { x, y, t: performance.now() };
        if (y > rect.height * 0.6 && Math.abs(x - rect.width/2) < rect.width * 0.2) return; // wait for swipe check
        if (x < rect.width / 2) setFlipper('left', true); else setFlipper('right', true);
      });
      overlay.addEventListener('pointerup', (e) => {
        const rect = overlay.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        if (touchStart && touchStart.y > rect.height * 0.6 && (touchStart.x > rect.width*0.3 && touchStart.x < rect.width*0.7)) {
          const dy = touchStart.y - y;
          if (dy > 40) launchBall();
        }
        setFlipper('left', false);
        setFlipper('right', false);
        touchStart = null;
      });
    }

    function resetGame() {
      score = 0; miss = 0;
      scoreEl.textContent = score;
      missEl.textContent = miss;
      respawnBall();
    }

    let lastTime;
    function animate(time) {
      requestAnimationFrame(animate);
      if (!lastTime) lastTime = time;
      const dt = Math.min((time - lastTime) / 1000, 0.03);
      const fixedTimeStep = 1/60;
      let accumulator = dt;
      while (accumulator >= fixedTimeStep) {
        world.step(fixedTimeStep);
        accumulator -= fixedTimeStep;
      }
      lastTime = time;

      ballMesh.position.copy(ballBody.position);
      ballMesh.quaternion.copy(ballBody.quaternion);
      Object.values(flippers).forEach(f => {
        f.mesh.position.copy(f.body.position);
        f.mesh.quaternion.copy(f.body.quaternion);
      });

      renderer.render(scene, camera);
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
  </script>
</body>
</html>
